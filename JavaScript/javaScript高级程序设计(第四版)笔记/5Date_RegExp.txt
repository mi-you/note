》5.1Date
	》Date.parse()和Date.UTC()可以返回日期的毫秒数
		Date.parse('5/23/2019');Date.UTC(2005,4,5,17,55,55)
		Date.UTC参数：年、零起点月、日、时、分、秒年月为必填项()
	》new Date():要基于其他日期和时间创建日期对象必须给其传入毫秒表示，
		new Date('5/23/2019')会在后台调用Date.parse('5/23/2019')
		new Date(2019,4,23)会在后台调用Date.UTC(2019,4,23)
		值得注意的是：隐式调用Date.UTC创建的是本地日期，无论隐式还是显示调用Date.parse()创建的都是本地日期
		new Date(2019,4,23).getTime() - new Date(Date.UTC(2019,4,23)).getTime()的值是时区差秒数(中国8*60*60*1000)
		new Date(2019,4,23).getTime() = new Date('5/23/2019') = new Data(Date.parse('5/23/2019'))
	》Date.now() 返回表示方法执行日期和时间的毫秒数(本地)，这个方法可以方便的计算代码的运行时间
		let start = Date.now();let end = Date.now()
	》getTime() //与valueOf()相同返回的是日期的毫秒数
	》getFullYear() //返回4位年数
	》getMonth() //返回月0-11
	》getDate() //返回日1-31
	》getDay() //返回日期中表示周几的数值0-6,0：周日
	》getHours() // 0-23
	》getMinutes() //0-59
	》getSeconds() //0-59
	》getMilliseconds() //返回日期中的毫秒数
》5.2RegExp
	》模式
		g-全局	i-不区分大小写 	
		m-多行模式	y-粘附模式，表示只查找从lastIndex开始	u-Unicode模式，启用Unicode	s-dotAll,表示元字符，匹配任何字符
	》元字符在模式中必须转义，包括
		([{\^$\)]}?*+.
	》/\\123/ 的对应字符串 “\\\\123”
	》RegExp也可以基于正则表达式实例选择性地修改它们的标记
		const rel = /cat/g;
		const rel2 = new RegExp(rel,'i')
	》RegExp实例属性
		global 布尔值 是否设置g标记
		ignoreCase 布尔值 是否设置i标记
		unicode 布尔值 是否设置u标记
		sticky 布尔值 是否设置y标记
		lastIndex 整数 表示在源字符串中下一次搜索的开始位置，始终从0开始
		multiline 布尔值 表示是否设置m标记
		dotAll 布尔值 是否设置s标记
		source 正则表达式的字面量字符串。始终以字面量而非传入构造函数的字符串形式返回，没有开头和结尾的斜杠
		flags 正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串形式返回，没有开头和结尾的斜杠
	》exec() :正则表达式的主要方法，接收一个参数，即要应用的模式的字符串，如果找到匹配项返回包含第一个匹配信息的数组
		如果没有找到匹配项返回null
		var pat = /[0-9,a-z,A-Z](([A-z])?([0-9])?([A-z])?)?/g;var b = pat.exec('ab3cde2fgh');console.log(b,b.index,b.input);var c = pat.exec('ab3cde2fgh');console.log(c,c.index,c.input)
		//["ab3c", "b3c", "b", "3", "c", index: 0, input: "ab3cde2fgh", groups: undefined] 0 "ab3cde2fgh"
		//["de2f", "e2f", "e", "2", "f", index: 4, input: "ab3cde2fgh", groups: undefined] 4 "ab3cde2fgh"
		如果模式设置了粘附标记 y，则每次调用 exec()就只会在 lastIndex 的位置上寻找匹配项。
		粘附标记覆盖全局标记
	》test() :接收一个字符串参数。如果输入的文本与模式匹配，则参数返回 true，否则返回 false。
	》toLocaleString()和 toString()返回的都是其字面量的形式
	》valueOf()方法返回正则表达式本身
	》RegExp构造函数属性：RegExp 构造函数的所有属性都没有任何 Web 标准出处，因此不要在生产环境中使用它们
		这些属性还有一个特点，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写
		input $_ 最后搜索的字符串（非标准特性）
		lastMatch $& 最后匹配的文本
		lastParen $+ 最后匹配的捕获组（非标准特性）
		leftContext $` input 字符串中出现在 lastMatch 前面的文本
		rightContext $' input 字符串中出现在 lastMatch 后面的文本
		
		let text = "this has been a short summer"; 
		let pattern = /(.)hort/g; 
		if (pattern.test(text)) { 
		 console.log(RegExp.input); // this has been a short summer 
		 console.log(RegExp.leftContext); // this has been a 
		 console.log(RegExp.rightContext); // summer 
		 console.log(RegExp.lastMatch); // short 
		 console.log(RegExp.lastParen); // s 
		}
		input 属性中包含原始的字符串。
 		leftConext 属性包含原始字符串中"short"之前的内容，
		rightContext 属性包含"short"之后的内容。
 		lastMatch 属性包含匹配整个正则表达式的上一个字符串，即"short"
		lastParen 属性包含捕获组的上一次匹配，即"s"。
》5.3原始值包装类型
	》Boolean
	》Number
		》toFixed() // 保留几位小数：接收一个参数，实测不传相当于传0
		》toExponential() // 返回科学计数法：接收一个参数
		》toPrecision() /// 根据情况返回最合理的输出结果：接收一个参数，表示结果中数字的总位数(不包括指数)
		本质上toPercision方法是根据数值和精度来决定调用toFixed()还是toExponential()
		》Number.isInteger()方法用于辨别一个数值是否保存为整数，有时候小数后的0可能会让人误认为数值是个浮点数
		console.log(Number.isInteger(1.00)) //true
		》Number.isSafeInteger()判断整数是否是安全整数(-2^53+1)~(2^53-1)
	》String
		JavaScript 字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。
		换句话说，字符串的 length 属性表示字符串包含多少 16 位码元
		》charAt() //返回给定索引位置的字符
		》charCodeAt() //查看指定码元的字符编码
		JavaScript 字符串使用了两种 Unicode 编码混合的策略：UCS-2 和 UTF-16。对于可以采用 16 位编码
		的字符（U+0000~U+FFFF），这两种编码实际上是一样的
	
	
	
	
》	page119 - page120的关于字符的内容有时间看看扩展
》	indeOf(),lastIndexOf()都接受第二个参数表示开始搜索的位置
	includes(),startWith(),endWith()都接受第二个参数，前两个表示是开始位置，后一个表示字符串"末尾"位置
	trim(),trimLeft(),trimRight()
	repeat()表示要将字符串重复多少次
	padStart(),padEnd()第一个参数是长度，第二个可选的是填充的字符串默认空格
		let a = 'aa';a.padEnd(4,'b') === aabb

》toLowerCase(),toUpperCase(),toLocaleLowerCase(),toLocaleUpperCase()
》字符串的replace方法接收两个参数
	1、RegExp对象或字符串:
	2、字符串或一个函数:
		字符串的情况下有几个特殊的字符序列，可以用来插入正则表达式操作的值,详细见page126
			'abcde'.replace(/(.)/,'*$1.') // *a.*b.*c.*d.*e.
		函数,详见page126
			funtion htmlEscape(test){
				return text.replace(/[<>"&]/,(match,pos,orignalText) => {
					switch(match){
						case '<':return '&lt;'
						case '>':return '&gt;'
						case '&':return '&amp;'
						case '"':return '&quot;'
					}
				})
			}
》字符串的split方法还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小
	let str = 'a,b,c,d,e'
	console.log(str.split(",",2)) // ['a','b']
	console.log(str.split(",",0)) // []
	console.log(str.split(",",-2)) // ['a','b','c','d','e']
》encodeURI():不会编码属于URL组件的特殊字符，比如冒号、斜杠、问号、井号
	encodeURIComponent():编码它发现的所有非标准字符
	使用encodeURI编码整个URI,使用encodeURIComponent编码那些会追加到已有URI后面的字符串
	decodeURI()和decodeURIComponent()
》Global:ECMAScript中最特别的对象，代码不会显示的访问它，ECMA-262规定Global对象为一种兜底对象，
	它所针对的是不属于任何对象的属性和方法。事实上不存在全局变量或全局函数这种东西。在全局作用域中
	定义的变量和函数都会变成Global对象的属性。isNaN()、isFinite()、parseInt()、parseFloat()
	实际上都是Global对象的方法
	Global对象的属性
		undefined、NaN、Infinity、Object、Array、Sring...更多属性见page 130
	let global = function(){return this}();可以获取Global对象
》Math.min(),Math.max()、Math.ceil()、Math.floor()、Math.round()、
	Math.fround():返回数值最接近的单精度(32位)浮点表示
	window.crypto.getRandomValues(typeArray)获取密码学要求的安全的随机值，参数是typeArray
