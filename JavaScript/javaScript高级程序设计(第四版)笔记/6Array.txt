》6.2Array
	》创建数组
		》使用Array构造函数：在使用 Array 构造函数时，也可以省略 new 操作符
			let colors = new Array(3); // 创建一个包含 3 个元素的数组
			let names = new Array("Greg"); // 创建一个只包含一个元素，即字符串"Greg"的数组
			let names = Array("Greg")
		》使用数组字面量：与对象一样，在使用数组字面量表示法创建数组不会调用 Array 构造函数
			let colors = ["red", "blue", "green"]; // 创建一个包含 3 个元素的数组
			let names = []; // 创建一个空数组
			let values = [1,2,]; // 创建一个包含 2 个元素的数组
		》from()和 of()：Array 构造函数还有两个 ES6 新增的用于创建数组的静态方法
	》from(),of()数组的方法
		》Array.from():用于将类数组结构转换为数组实例
			// 字符串会被拆分为单字符数组
			console.log(Array.from("Matt")); // ["M", "a", "t", "t"] 
			// 可以使用 from()将集合和映射转换为一个新数组
			const m = new Map().set(1, 2) .set(3, 4); 
			const s = new Set().add(1).add(2).add(3) .add(4); 
			console.log(Array.from(m)); // [[1, 2], [3, 4]] 
			console.log(Array.from(s)); // [1, 2, 3, 4] 
			// Array.from()对现有数组执行浅复制
			// 可以使用任何可迭代对象
			const iter = { 
			 *[Symbol.iterator]() { 
			 yield 1; 
			 yield 2; 
			 yield 3; 
			 yield 4; 
			 } 
			}; 
			console.log(Array.from(iter)); // [1, 2, 3, 4] 
			(可选)第二个参数是映射函数
			(可选)第三用于指定映射函数中this的值。不适用于第二个函数时箭头函数
			let a = [1,2,3,4]
			let b = Array.from(a,(x,index) => x**2) //[1,4,9,16]
			let c = Array.from(a,function(x){return x**this.exponent},{exponent:2}) //[1,4,9,16]
		》Array.of()可以把一组参数转换为数组。这个方法用于替代ES6之前常用的Array.prototype.clice.call(arguemnts)
			console.log(Array.of(1,2,3,4)) //[1,2,3,4]
			console.log(undefined) //[undefined]
	》实践中要避免使用数组空位，如果需要可以显示的用undefined值代替
	》可以通过修改数组的length属性删除数组项或增加数组项(undefined)
	》检测数组
		》value instanceof Array
		》Array.isArray()
	》keys(),values(),entries():返回的是索引、元素、索引/值对的迭代器：
		const a = ["foo", "bar", "baz", "qux"]; 
		// 因为这些方法都返回迭代器，所以可以将它们的内容
		// 通过 Array.from()直接转换为数组实例
		const aKeys = Array.from(a.keys()); 
		const aValues = Array.from(a.values()); 
		const aEntries = Array.from(a.entries()); 
		console.log(aKeys); // [0, 1, 2, 3] 
		console.log(aValues); // ["foo", "bar", "baz", "qux"] 
		console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]
		for (const [idx, element] of a.entries()) { 
		 alert(idx); 
		 alert(element); 
		}
	》fill():可接受第二(b)和第三个参数(c)代表插入的数组索引的范围,。负值索引从数组末尾开始计算
		const zeroes = [0,0,0,0,0]
		zeroes.fill(6,1,3) // [0,6,6,0,0]
		zeroes.fill(6,7,9) // [0,0,0,0,0]
		zeroes.fill(6,-2,-1) // [0,0,0,6,0]
		zeroes.fill(6,1) // [0,6,6,6,6]
	》copyWithin():按指定范围浅复制数组中的部分内容，然后将他们插入到指定索引开始的位置，
		静默忽略超出数组边界、零长度及方向相反的索引范围
		let ints = [0,1,2,3,4,5,6,7,8,9]
		ints.copyWithin(5) //[0,1,2,3,4,0,1,2,3,4]
		//复制索引5开始的内容，插入到索引0开始的位置
		ints.copyWithin(0,5) //[5,6,7,8,9,5,6,7,8,9]
		ints.copyWithin(4,0,3) //[1,2,3,0,1,2,7,8,9]
	》toLocaleString(),toString(),valueOf()：这是所有对象上都有的属性，此外还有
		constructor,hasOwnProperty(propertyName),isPrototypeOf(Object),propertyIsEnumerable(propertyName)
	》join():接收一个参数，即字符串分隔符，返回包含所有项的字符串
		如果不给 join()传入任何参数，或者传入 undefined，则仍然使用逗号作为分隔符,
		如果数组中某一项是 null 或 undefined，
		则在 join()、toLocaleString()、toString()返回的结果中会以空字符串表示
	》push()和unshift()都接受任意数量的参数,并将他们添加到数组末尾(开始)，返回数组的最新长度
	》pop(),shift()删除数组的末尾(开始)项并返回
	》reverse() 将数组反向排列,返回调用它们的数组索引
	》sort() 返回调用它们的数组索引
		》默认调用sort()会按照升序重新排列数组(从小到大),字符串比较，即使是数字也会转换成字符串再比较
			let values = [0, 1, 5, 10, 15]; 
			values.sort(); // 0,1,10,15,5
		》函数可以接受一个比较函数，比较函数接收两个参数，
			如果第一个参数应该排在第二个参数前面就返回负值
			如果两个参数相等，就返回 0；
			如果第一个参数应该排在第二个参数后面，就返回正值。
			let values = [0, 1, 5, 10, 15]; 
			values.sort((a,b) => a-b); //  0,1,5,10,15
	》concat() 返回新的数组
		如果传入一个或多个数组，则 concat()会把这些数组的每一项都添加到结果数组。	
		如果参数不是数组，则直接把它们添加到结果数组末尾。
		let arr = ["black", "brown"],obj = {length: 2,0: "pink",1: "cyan"}
		let colors = ["red", "green", "blue"]; 
		let colors2 = colors.concat("yellow", arr); 
		let colors3 = colors.concat("yellow", obj)
		console.log(colors); // ["red", "green","blue"] 
		console.log(colors2); // ["red", "green", "blue", "yellow", "black", "brown"]
		console.log(colors3); // ["red", "green", "blue", {length: 2,0: "pink",1: "cyan"}]
		打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcatSpreadable。
		这个符号能够阻止 concat()打平参数数组。相反，把这个值设置为 true 可以强制打平类数组对象
		arr[Symbol.isConcatSpreadable] = false;
		obj[Symbol.isConcatSpreadable] = true;
		let colors22 = colors.concat("yellow", arr); 
		let colors33 = colors.concat("yellow", obj)
		console.log(colors); // ["red", "green","blue"] 
		console.log(colors22); // ["red", "green", "blue", "yellow", ["black", "brown"]]
		console.log(colors33); // ["red", "green", "blue", "yellow","pink","cyan"]
	》slice() 
		用于创建一个包含原有数组中一个或多个元素的新数组。
		可以接收一个或两个参数(开始索引和结束索引),负值相当于数组长度加上这个值
		let colors = ["red", "green", "blue", "yellow", "purple"]; 
		let colors2 = colors.slice(1); // green,blue,yellow,purple 
		let colors3 = colors.slice(1, 4); // green,blue,yellow
		let colors3 = colors.slice(-4, -3); // green
	》splice() 始终返回这样一个数组，包含从数组中被删除的元素
		》删除：需要给 splice()传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从
			数组中删除任意多个元素，比如 splice(0, 2)会删除前两个元素
		》插入：需要给 splice()传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可
			以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多
			个要插入的元素。比如，splice(2, 0, "red", "green")会从数组位置 2 开始插入字符串
			"red"和"green"。  
		》替换：splice()在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位
			置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量
			一致。比如，splice(2, 1, "red", "green")会在位置 2 删除一个元素，然后从该位置开始
			向数组中插入"red"和"green"
	》indexOf(),lastIndexOf(),includes()
		》这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置
		》indexOf()和lastIndexOf() 返回元素在数组中的位置或-1
		》includes() 返回布尔值
		let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; 
		alert(numbers.indexOf(4)); // 3 
		alert(numbers.lastIndexOf(4)); // 5 
		alert(numbers.includes(4)); // true 
		alert(numbers.indexOf(4, 4)); // 5 
		alert(numbers.lastIndexOf(4, 4)); // 3 
		alert(numbers.includes(4, 7)); // false
	》find()和findIndex()方法使用了断言函数，找到匹配项后，这两个方法都不再继续搜索。
		》断言函数接收3个参数：元素、索引和数组本身。
		let arr = [1,2,3,4,5,6,7,8,9];
		a.find((el,index,array) => el > 2) //3
		a.findIndex((el,index,array) => el > 2) //2
		》可选第二个参数指定断言函数内部this(断言函数不要用箭头函数)
		a.find(function(el,index,array){return el > this.value},{value:2}) //3
		a.findIndex(function(el,index,array){return el > this.value},{value:2}) //2
	》every(),filter(),forEach(),map(),some()
		》每个方法接收两个参数：
			1、以每一项为参数运行的函数（函数接收 3个参数：数组元素、元素索引和数组本身）
			2、可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）
		》every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。  
		》filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。
		》forEach()：对数组每一项都运行传入的函数，没有返回值。
		》map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。
		》some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true		
	》reduce()和reduceRight() 除遍历数组元素的方向，这两个方法没什么区别。
		》都接受两个参数：归并函数和可选的起点初始值。
			归并函数接收四个参数：上一个归并值、当前项、当前项的索引和数组本身
		》如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，
			因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。
		let values = [1, 2, 3, 4, 5]; 
		let sum = values.reduce((prev, cur, index, array) => prev + cur); // 15
		let sum2 = values.reduce((prev, cur, index, array) => prev + cur,10); // 25
		
		
》定型数组，DataView,ArrayBuffer见page155
》Map:为这门语言带来了真正的键值存储机制。可以使用任何JavaScript数据类型作为键，键的比较采用SameValueZero
	set(),get(),has(),size(),delete(),clear()
》WeakMap：弱映射中的键只能是Object或继承自Object的类型，由于键值对任何时候都可能被销毁，
	所有没必要提供其迭代键值对的能力，没有clear()方法
》Set:add(),has(),size(),delete(),clear()

》生成器函数只会在初次调用next()方法后开始执行
	function* generationFn(){
		console.log('foo')
	}
	let generationObj = generationFn();// 并不会打印日志
	generationObj.next();// foo
	》yield关键字只能在生成器函数内部使用，用在其他地方会抛出错误

》ECMA-262使用一些内部特性来描述属性特征。这些特性是由为JavaScript实现引擎的规范定义的。因此，开发者不能在JavaScript
	中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来比如[[Enumerable]]
	属性分两种：数据属性和访问器属性。
	》数据属性有四个特性描述他们的行为
		[[Configurable]]、[[Enumerable]]、[[Writable]]、[[Value]]
	》一个属性被定义为不可配置后，就不能在变回可配置的了。再次调用Object.defineProperty()并修改writable属性
		或导致错误。因此虽然可以对同一个属性多次调用Object.defineProperty()但是把configurable设置为false
		之后就会受限制。在调用Object.defineProperty()后configurable、enumerable、writable不指定默认为false
》Object.propertyIsEnumerable(),Object.hasOwnProperty()
》 //这些情况再不同JavaScript引擎中表现不同，但被认为相同
	+0 === -0 // true
	+0 === 0 //true
	-0 === 0 //true
	// 要确定NaN的相等性，必须使用isNaN()
	为改善这类情况ECMAScript 6规范新增Object.is()这个方法与===很像，但同时考虑到了上述边界情况。该方法接受两个参数
	Object.is(+0,-0) // false
	Object.is(+0,0) // true
	Object.is(-0,0) // true
	Object.is(NaN,NaN) //true
	// 要检查超过两个值，递归地利用相等性传递即可
	function recursivelyCheckEqual(x,....rest){
		return Object.is(x,rest[0]) && (rest.length < 2 || recursivelyCheckEqual(...rest));
	}
》解构并不要求变量必须在解构表达式中声明，不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中
	let personName,personAge;
	let person = {name:'aa',age:24};
	({name:personName,age:personAge} = person);
	通过这种方式可以给对象赋值
	let a = {}
	({name:a.name,age:a.age} = person)
》使用Object.getPrototypeOf()可以方便的取得一个对象的原型
	funtion Person(){}
	let child = new Person() //或new Person
	child.__proto__ === Person.protoType // true
	Object.getPrototypeOf(child) === Person.protoType // true
》Object.setProtoTypeOf()可以重写一个对象的原型，为了避免使用Object.setProtoTypeOf()可能造成的性能下降，
	可以通过Object.create()来创建一个新对象，同时为其指定原型
	let biped = {numLegs :2}
	let person = Object.create(biped);
	Object.getPrototypeOf(person) === biped // true
》hasOwnProperty() //不会去原型上查找属性
》原型和in操作符
	》有两种方式使用in操作符：单独使用和在for-in循环中使用
	单独使用时，会在原型上查找属性
		let a = Object.creact({name:'a'})
		'name' in a // true name在a的原型链上
		和hasOwnProperty()一起使用可以判断属性是在实例上还是原型上
	for-in中使用，也会在原型上查找，[[Enumerable]]为false的实例或原型属性不会被枚举
	Object.keys()返回实例上可枚举属性
》Object.create()可接受第二个可选参数，是给新对象定义额外属性的对象，与Object.defineProperties()的第二个参数一样

》实现递归的函数,这个函数避免了严格模式下访问arguments.callee报错的问题
	const factorial = (function f(num){
		if(num <= 1){
			return 1;
		}else{
			return num + f(num - 1)
		}
	})
》尾调用优化递归
	function fib(n){ 
		return fibImpl(0,1,n)
	}
	function fibImpl(a,b,n){
		if(n===0){return a}
		return fibImpl(b,a+b,n-1)
	}
	console.log(fib(1000))(浏览器轻松计算)
	原递归(fibb(1000)浏览器处理不了)
	function fibb(n){
		if(n<2)return n;
		return fibb(n-1) + fibb(n-2)
	}
	
	
/*************************************************************h5扩展*****************************************************/


/************************************************************************************************************************/
》performence.now() //DOMHighResTimeStamp
	start = performence.now()
	end = performence.now()
	end - start


/************************************************************ 19 表单 ***************************************************/
》表单提交
	<input type='submit' value='提交' />
	<button type='submit'>提交</button>
	<input type='image' src='./a.jpg' />

》input 的size属性可以指定文本框的宽度(字数)
	<input size='10' maxLength='50' />
》textarea 不能在HTML中指定最大允许字符数
》两种文本框都支持一个名为select()的方法用于选中全部的文本与之相对，还有一个select事件
	textbox.value.substring(textbox.selecttionStart,textbox.selecttionEnd)
	调用select()后文本框会自动获取焦点(Opera除外)
》setSelectionRange()可以用于选中部分文本：参数第一个字符的索引和停止选择的字符索引
	textbox.setSelectionRange(0,textbox.value.length)
	要想看到选择则必须在调用setSelectionRange()之前或之后给文本设置焦点
》剪切板事件
	》beforecopy:复制操作发生前
	》copy:复制操作发生时
	》beforecut:剪切操作发生前
	》cut:剪切操作发生时
	》beforepaste:粘贴操作发生前触发
	》paste:粘贴操作发生时触发
》pattern属性可以验证输入值是否有效，结果可以在元素的checkValidity()上查看，validity可以查看具体的无效原因
	在表单form上调用checkValidity()可以确认整个表单是否有效,
	在表单form上添加novalidate属性或通过js将改属性设置为true可以避免表单验证
》select 中的size为选框的可见行数













