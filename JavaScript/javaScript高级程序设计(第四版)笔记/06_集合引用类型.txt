》6.1Object
	》对象字面量({})和new Object():在使用对象字面量表示法定义对象时，并不会实际调用 Object 构造函数
》6.2Array
	》创建数组
		》使用Array构造函数：在使用 Array 构造函数时，也可以省略 new 操作符
			let colors = new Array(3); // 创建一个包含 3 个元素的数组
			let names = new Array("Greg"); // 创建一个只包含一个元素，即字符串"Greg"的数组
			let names = Array("Greg")
		》使用数组字面量：与对象一样，在使用数组字面量表示法创建数组不会调用 Array 构造函数
			let colors = ["red", "blue", "green"]; // 创建一个包含 3 个元素的数组
			let names = []; // 创建一个空数组
			let values = [1,2,]; // 创建一个包含 2 个元素的数组
		》from()和 of()：Array 构造函数还有两个 ES6 新增的用于创建数组的静态方法
	》from(),of()数组的方法
		》Array.from():用于将类数组结构转换为数组实例
			// 字符串会被拆分为单字符数组
			console.log(Array.from("Matt")); // ["M", "a", "t", "t"] 
			// 可以使用 from()将集合和映射转换为一个新数组
			const m = new Map().set(1, 2) .set(3, 4); 
			const s = new Set().add(1).add(2).add(3) .add(4); 
			console.log(Array.from(m)); // [[1, 2], [3, 4]] 
			console.log(Array.from(s)); // [1, 2, 3, 4] 
			// Array.from()对现有数组执行浅复制
			// 可以使用任何可迭代对象
			const iter = { 
			 *[Symbol.iterator]() { 
			 yield 1; 
			 yield 2; 
			 yield 3; 
			 yield 4; 
			 } 
			}; 
			console.log(Array.from(iter)); // [1, 2, 3, 4] 
			(可选)第二个参数是映射函数
			(可选)第三用于指定映射函数中this的值。不适用于第二个函数时箭头函数
			let a = [1,2,3,4]
			let b = Array.from(a,(x,index) => x**2) //[1,4,9,16]
			let c = Array.from(a,function(x){return x**this.exponent},{exponent:2}) //[1,4,9,16]
		》Array.of()可以把一组参数转换为数组。这个方法用于替代ES6之前常用的Array.prototype.clice.call(arguemnts)
			console.log(Array.of(1,2,3,4)) //[1,2,3,4]
			console.log(undefined) //[undefined]
	》实践中要避免使用数组空位，如果需要可以显示的用undefined值代替
	》可以通过修改数组的length属性删除数组项或增加数组项(undefined)
	》检测数组
		》value instanceof Array
		》Array.isArray()
	》keys(),values(),entries():返回的是索引、元素、索引/值对的迭代器：
		const a = ["foo", "bar", "baz", "qux"]; 
		// 因为这些方法都返回迭代器，所以可以将它们的内容
		// 通过 Array.from()直接转换为数组实例
		const aKeys = Array.from(a.keys()); 
		const aValues = Array.from(a.values()); 
		const aEntries = Array.from(a.entries()); 
		console.log(aKeys); // [0, 1, 2, 3] 
		console.log(aValues); // ["foo", "bar", "baz", "qux"] 
		console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]
		for (const [idx, element] of a.entries()) { 
		 alert(idx); 
		 alert(element); 
		}
	》fill():可接受第二(b)和第三个参数(c)代表插入的数组索引的范围,。负值索引从数组末尾开始计算
		const zeroes = [0,0,0,0,0]
		zeroes.fill(6,1,3) // [0,6,6,0,0]
		zeroes.fill(6,7,9) // [0,0,0,0,0]
		zeroes.fill(6,-2,-1) // [0,0,0,6,0]
		zeroes.fill(6,1) // [0,6,6,6,6]
	》copyWithin():按指定范围浅复制数组中的部分内容，然后将他们插入到指定索引开始的位置，
		静默忽略超出数组边界、零长度及方向相反的索引范围
		let ints = [0,1,2,3,4,5,6,7,8,9]
		ints.copyWithin(5) //[0,1,2,3,4,0,1,2,3,4]
		//复制索引5开始的内容，插入到索引0开始的位置
		ints.copyWithin(0,5) //[5,6,7,8,9,5,6,7,8,9]
		ints.copyWithin(4,0,3) //[1,2,3,0,1,2,7,8,9]
	》toLocaleString(),toString(),valueOf()：这是所有对象上都有的属性，此外还有
		constructor,hasOwnProperty(propertyName),isPrototypeOf(Object),propertyIsEnumerable(propertyName)
	》join():接收一个参数，即字符串分隔符，返回包含所有项的字符串
		如果不给 join()传入任何参数，或者传入 undefined，则仍然使用逗号作为分隔符,
		如果数组中某一项是 null 或 undefined，
		则在 join()、toLocaleString()、toString()返回的结果中会以空字符串表示
	》push()和unshift()都接受任意数量的参数,并将他们添加到数组末尾(开始)，返回数组的最新长度
	》pop(),shift()删除数组的末尾(开始)项并返回
	》reverse() 将数组反向排列,返回调用它们的数组索引
	》sort() 返回调用它们的数组索引
		》默认调用sort()会按照升序重新排列数组(从小到大),字符串比较，即使是数字也会转换成字符串再比较
			let values = [0, 1, 5, 10, 15]; 
			values.sort(); // 0,1,10,15,5
		》函数可以接受一个比较函数，比较函数接收两个参数，
			如果第一个参数应该排在第二个参数前面就返回负值
			如果两个参数相等，就返回 0；
			如果第一个参数应该排在第二个参数后面，就返回正值。
			let values = [0, 1, 5, 10, 15]; 
			values.sort((a,b) => a-b); //  0,1,5,10,15
	》concat() 返回新的数组
		如果传入一个或多个数组，则 concat()会把这些数组的每一项都添加到结果数组。	
		如果参数不是数组，则直接把它们添加到结果数组末尾。
		let arr = ["black", "brown"],obj = {length: 2,0: "pink",1: "cyan"}
		let colors = ["red", "green", "blue"]; 
		let colors2 = colors.concat("yellow", arr); 
		let colors3 = colors.concat("yellow", obj)
		console.log(colors); // ["red", "green","blue"] 
		console.log(colors2); // ["red", "green", "blue", "yellow", "black", "brown"]
		console.log(colors3); // ["red", "green", "blue", {length: 2,0: "pink",1: "cyan"}]
		打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcatSpreadable。
		这个符号能够阻止 concat()打平参数数组。相反，把这个值设置为 true 可以强制打平类数组对象
		arr[Symbol.isConcatSpreadable] = false;
		obj[Symbol.isConcatSpreadable] = true;
		let colors22 = colors.concat("yellow", arr); 
		let colors33 = colors.concat("yellow", obj)
		console.log(colors); // ["red", "green","blue"] 
		console.log(colors22); // ["red", "green", "blue", "yellow", ["black", "brown"]]
		console.log(colors33); // ["red", "green", "blue", "yellow","pink","cyan"]
	》slice() 
		用于创建一个包含原有数组中一个或多个元素的新数组。
		可以接收一个或两个参数(开始索引和结束索引),负值相当于数组长度加上这个值
		let colors = ["red", "green", "blue", "yellow", "purple"]; 
		let colors2 = colors.slice(1); // green,blue,yellow,purple 
		let colors3 = colors.slice(1, 4); // green,blue,yellow
		let colors3 = colors.slice(-4, -3); // green
	》splice() 始终返回这样一个数组，包含从数组中被删除的元素
		》删除：需要给 splice()传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从
			数组中删除任意多个元素，比如 splice(0, 2)会删除前两个元素
		》插入：需要给 splice()传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可
			以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多
			个要插入的元素。比如，splice(2, 0, "red", "green")会从数组位置 2 开始插入字符串
			"red"和"green"。  
		》替换：splice()在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位
			置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量
			一致。比如，splice(2, 1, "red", "green")会在位置 2 删除一个元素，然后从该位置开始
			向数组中插入"red"和"green"
	》indexOf(),lastIndexOf(),includes()
		》这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置
		》indexOf()和lastIndexOf() 返回元素在数组中的位置或-1
		》includes() 返回布尔值
		let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; 
		alert(numbers.indexOf(4)); // 3 
		alert(numbers.lastIndexOf(4)); // 5 
		alert(numbers.includes(4)); // true 
		alert(numbers.indexOf(4, 4)); // 5 
		alert(numbers.lastIndexOf(4, 4)); // 3 
		alert(numbers.includes(4, 7)); // false
	》find()和findIndex()方法使用了断言函数，找到匹配项后，这两个方法都不再继续搜索。
		》断言函数接收3个参数：元素、索引和数组本身。
		let arr = [1,2,3,4,5,6,7,8,9];
		a.find((el,index,array) => el > 2) //3
		a.findIndex((el,index,array) => el > 2) //2
		》可选第二个参数指定断言函数内部this(断言函数不要用箭头函数)
		a.find(function(el,index,array){return el > this.value},{value:2}) //3
		a.findIndex(function(el,index,array){return el > this.value},{value:2}) //2
	》every(),filter(),forEach(),map(),some()
		》每个方法接收两个参数：
			1、以每一项为参数运行的函数（函数接收 3个参数：数组元素、元素索引和数组本身）
			2、可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）
		》every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。  
		》filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。
		》forEach()：对数组每一项都运行传入的函数，没有返回值。
		》map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。
		》some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true		
	》reduce()和reduceRight() 除遍历数组元素的方向，这两个方法没什么区别。
		》都接受两个参数：归并函数和可选的起点初始值。
			归并函数接收四个参数：上一个归并值、当前项、当前项的索引和数组本身
		》如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，
			因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。
		let values = [1, 2, 3, 4, 5]; 
		let sum = values.reduce((prev, cur, index, array) => prev + cur); // 15
		let sum2 = values.reduce((prev, cur, index, array) => prev + cur,10); // 25
		
		
》6.3定型数组
	是 ECMAScript 新增的结构，目的是提升向原生库传输数据的效率。实际上，
	JavaScript 并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。
	》DataView
		必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView 实例
		const buf = new ArrayBuffer(16); 
		// DataView 默认使用整个 ArrayBuffer 
		const fullDataView = new DataView(buf); 
		alert(fullDataView.byteOffset); // 0 
		alert(fullDataView.byteLength); // 16 
		alert(fullDataView.buffer === buf); // true 
		// 构造函数接收一个可选的字节偏移量和字节长度
		// byteOffset=0 表示视图从缓冲起点开始
		// byteLength=8 限制视图为前 8 个字节
		const firstHalfDataView = new DataView(buf, 0, 8); 
		alert(firstHalfDataView.byteOffset); // 0 
		alert(firstHalfDataView.byteLength); // 8 
		alert(firstHalfDataView.buffer === buf); // true
	》定性数组：设计定型数组的目的就是提高与 WebGL 等原生库交换二进制数据的效率
》6.4Map
	》Object 只能使用数值、字符串或符号作为键。Map可以使用任何JavaScript数据类型作为键，键的比较采用SameValueZero。
	》与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序
	》set(),get(),has(),size(),delete(),clear()
	》delete()返回一个布尔值，表示集合中是否存在要删除的值
》6.5WeakMap
	弱映射中的键只能是Object或继承自Object的类型，由于键值对任何时候都可能被销毁，
	所有没必要提供其迭代键值对的能力
	》set(),get(),has(),size(),delete()没有clear()方法
	》弱映射造就了在 JavaScript 中实现真正私有变量的一种新方式
	》给DOM关联数据
		const wm = new WeakMap(); 
		const loginButton = document.querySelector('#login'); 
		// 给这个节点关联一些元数据
		wm.set(loginButton, {disabled: true});
》6.6Set
	》add(),has(),size(),delete(),clear()
	》delete()返回一个布尔值，表示集合中是否存在要删除的值
》6.7WeakSet
	》弱集合中的值只能是 Object 或者继承自 Object 的类型，没有clear()方法
	》相比于 WeakMap 实例，WeakSet 实例的用处没有那么大不过，弱集合在给对象打标签时还是有
	价值的
	const disabledElements = new WeakSet(); 
	const loginButton = document.querySelector('#login'); 
	// 通过加入对应集合，给这个节点打上“禁用”标签
	disabledElements.add(loginButton); 
	这样，只要 WeakSet 中任何元素从 DOM 树中被删除，垃圾回收程序就可以忽略其存在，而立即
	释放其内存（假设没有其他地方引用这个对象）
》6.8迭代和扩展操作














