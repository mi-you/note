在软件开发领域，“迭代”的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件
》7.1理解迭代
》7.2迭代器模式
	》任何实现 Iterable 接口的数据结构都可以被实现 Iterator 接口的结构“消费”（consume）。
	》实现 Iterable 接口（可迭代协议）要求同时具备两种能力：
	支持迭代的自我识别能力和创建实现Iterator 接口的对象的能力。
	在 ECMAScript 中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的 Symbol.iterator 作为键。
	这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。
》7.3生成器
	生成器是 ECMAScript 6 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的
	能力。这种新能力具有深远的影响，比如，使用生成器可以自定义迭代器和实现协程。
	》 生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。
	// 生成器函数声明
	function* generatorFn() {} 
	// 生成器函数表达式
	let generatorFn = function* () {} 
	// 作为对象字面量方法的生成器函数
	let foo = { 
	 * generatorFn() {} 
	} 
	// 作为类实例方法的生成器函数
	class Foo { 
	 * generatorFn() {} 
	} 
	// 作为类静态方法的生成器函数
	class Bar { 
	 static * generatorFn() {} 
	}
	》箭头函数不能用来定义生成器函数。标识生成器函数的星号不受两侧空格的影响
	》调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态。与迭代器相似，
	生成器对象也实现了 Iterator 接口，因此具有 next()方法。调用这个方法会让生成器开始或恢复执行，
	next()方法的返回值类似于迭代器，有一个 done 属性和一个 value 属性。函数体为空的生成器函数中间不会停留，
	调用一次 next()就会让生成器到达 done: true 状态。
	》生成器函数只会在初次调用next()方法后开始执行
	function* generationFn(){
		console.log('foo')
	}
	let generationObj = generationFn();// 并不会打印日志
	generationObj.next();// foo
	》yield关键字只能在生成器函数内部使用，用在其他地方会抛出错误
	》在生成器对象上显式调用 next()方法的用处并不大。其实，如果把生成器对象当成可迭代对象，那么使用起来会更方便
	》除了可以作为函数的中间返回语句使用，yield 关键字还可以作为函数的中间参数使用，上一次让
	生成器函数暂停的 yield 关键字会接收到传给 next()方法的第一个值。这里有个地方不太好理解——
	第一次调用 next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数
	》这章看书比较好











